# -*- coding: utf-8 -*-
"""Prova de Calculo  numérico

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pHiQ1Rx8X9Zsxpo6tiMWTkQgcvOqKwvl

# Nadja Karla Araújo de Lima 
###Matrícula: 11514339

###Curso: Ciência da Computação
"""

#bibliotecas
from scipy.integrate import quad
import math
import numpy as np



"""**Questão 1): Calcule a integral pela regra de Simpson composta, usando oito divisões.**"""

from scipy.integrate import quad

#questão 1
#integrando com valor verdadeiro
def f(x):
    return (1 / (( x** 4) +1 ))
ans, err = quad(f, -1, 1)
print ("valor Exato:" , ans)

#resultado com sympson composto
def simpsonComp(f, a, b, n):

  h = (b-a)/n
  valor = 0
  for i in range(n+1):
    x = a + i*h
    y = f(x)

    if (i==0 or i==n):
      c = 1
    elif(i%2 == 0):
      c = 2
    else:
      c = 4
    multiplicaSimp= y * c
    valor += multiplicaSimp

    print(i, x, y, c)
  return (h/3)* valor


f = (lambda x : (1 / (( x** 4) +1 )))
a = -1
b = 1
n = 8

integral = simpsonComp(f, a, b, n)
print("valor aproximado:" , integral)

#calculando erro
erro = (ans - integral)
print("Erro absoluto: ", abs(erro))

"""**Questao 2): Calcule a integral a seguir pela regra dos Trapézios e pela regra 1/3 de Simpson composto com seis divisões. Calcule também o erro absoluto.**"""

#integrando com valor exato
def funcao2(x):
    return  2* math.sin(2*x)
    
ans, err = quad(funcao2, 0, np.pi)
print ("valor Exato:" , ans, " ou: ", int(ans), "\n")

#regra de simpson composto
def simpsonComp(f, a, b, n):

  h = (b-a)/n
  valor = 0
  for i in range(n+1):
    x = a + i*h
    y = f(x)

    if (i==0 or i==n):
      c = 1
    elif(i%2 == 0):
      c = 2
    else:
      c = 4
    multiplicaSimp= y * c
    valor += multiplicaSimp

    print(i, x, y, c)
  return (h/3)* valor

resultSimp = simpsonComp(funcao2, 0, np.pi, 6)
print("\naproximacao simpson composto: ", resultSimp)

#erro simpsonC
erro = (ans - resultSimp)
print("Erro absoluto: ", abs(erro), "\n")


#regra do trapezio composto
def trapComposto(f, a, b, n):

  h = (b-a)/n
  valor = 0
  for i in range(n+1):
    xi = a + i*h
    yi = f(xi)

    if (i==0 or i==n):
      t = 1
    else:
      t = 2

    multiplicaTrap = yi * t
    valor += multiplicaTrap

    print(i, xi, yi, t)
  return (h/2)* valor

resultTrap = trapComposto(funcao2, 0, np.pi, 6)
print("\naproximacao trapezio composto: ", resultTrap)

#erro simpsonC
erroTrap = (ans - resultTrap)
print("Erro absoluto: ", abs(erroTrap))

"""**Questão 3):**
*v'(t)=2000-2v(t)/200-t*

**Determine a velocidade do corpo v(t) no instante t = 5 segundos com
intervalos de 0,5 segundos, usando:
(a) Método de Euler aperfeiçoado;
(b) Método de Runge-Kutta de 40 ordem;**
"""

#Questão a)
def f(x, y):
    return  (2000-2*(y))/(200-x)

#formula do Método de Euler aperfeiçoado
#y1 = y0 + 1/2*(k1+k2)*h
#y0 = f(x0)
def metodoheun(h, n, x0, y0):

  x = x0
  y = y0
  for i in range (n):
    k1 = f(x, y)
    k2 = f(x + h, y + (h*k1))
    y = (y + (h/2)*(k1 + k2))
    x = x + h
    print(i,k1,k2)
  return y
      
resultHeun = metodoheun(0.5, 10, 0, 0)
print("Método de Euler aperfeiçoado:", resultHeun, "\n")

#questão b)
#Método de Runge-Kutta de 4ª ordem
def rungeKutta(h, n, x0, y0):

  x = x0
  y = y0
  for i in range (n):
      k1 = h  * f(x, y)
      k2 = h * f(x + h/2, y + (k1/2))
      k3 = h * f(x + h/2, y + (k2/2))
      k4 = h * f(x + h, y + k3)
      y = (y  + (k1+ (2*k2) + (2*k3) + k4)/6)
      x = x + h
      print(i,k1,k2,k3,k4)
  return y
      
resultrk = rungeKutta(0.5, 10, 0, 0)

print("Método de runge-kutta aperfeiçoado:", resultrk)

#Questão c
def f2(x):
    return  10*x -((x**2)/40)
  
solucaoExata =  f2(5)    
print("\nSolução exata:" , solucaoExata)

#erro absoluto do metodo de heun 
erro1 = (solucaoExata - resultHeun)
print("Erro absoluto do metodo de heun: ", abs(erro1))

#erro absoluto do metodo de rnge-kutta
erro2 = (solucaoExata - resultrk)
print("Erro absoluto do metodo de runge-kutta: ", abs(erro2))
print("\npode-se perceber que o método que possui o menor erro é o método de heun ou Euler aperfeiçoado")

"""Questão 4):"""

def funcaoX(y):
    return  2* (10**(-6)) * (100000 - y) * y

#Método de Runge-Kutta de 4ª ordem
def runge_Kutta(h,n,  y0):
  y = y0
  for i in range (n):
    k1 = h * funcaoX(y)
    k2 =  h * funcaoX(y + (k1/2))
    k3 = h * funcaoX(y + (k2/2))
    k4 = h * funcaoX(y + k3)
    y = (y  + (k1+ (2*k2) + (2*k3) + k4)/6)
    print(i,k1,k2,k3,k4)
  return y
      
resultado = runge_Kutta(0.5, 10, 1000)
print("\nMétodo de runge-kutta aperfeiçoado:", resultado)